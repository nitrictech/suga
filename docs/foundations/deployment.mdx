---
title: "Deployment"
description: "Understand how Suga applications are deployed to the cloud"
---

Deploying with Suga means running standard Terraform commands on the infrastructure generated by `suga build`. This page explains the deployment lifecycle, how to deploy to different environments, and best practices for production deployments.

## Deployment Overview

Suga's deployment model is transparent and uses standard tools:

1. **Generate Terraform** - `suga build` creates Terraform modules
2. **Configure Provider** - Set up cloud provider credentials and configuration
3. **Initialize Terraform** - Download providers and modules
4. **Preview Changes** - Review what will be created/modified
5. **Apply Changes** - Deploy to your cloud provider
6. **Verify Deployment** - Test deployed resources

## The Deployment Lifecycle

<Steps>
  <Step title="Build Infrastructure">
    Generate Terraform from your project:

    ```bash
    suga build
    ```

    Output:
    ```
    ✓ Terraform generated successfully
      output written to terraform/stacks/my-app

    Next steps:
    1. Run cd terraform/stacks/my-app to move to the stack directory
    2. Initialize the stack terraform init -upgrade
    3. Optionally, preview with terraform plan
    4. Deploy with terraform apply
    ```
  </Step>

  <Step title="Navigate to Stack">
    Change to the generated Terraform directory:

    ```bash
    cd terraform/stacks/my-app
    ```

    Contents:
    ```
    my-app/
    ├── cdk.tf.json          # Main Terraform Entrypoint
    └── .terraform/          # Plugin Terraform modules
        └── modules/
            ├── api/
            ├── api_image/
            ├── uploads_bucket/
            └── ...
    ```
  </Step>

  <Step title="Configure Cloud Provider">
    Set up provider configuration and credentials:

    <Tabs>
      <Tab title="AWS">
        ```bash
        # Configure credentials
        aws configure
        ```

        Create provider configuration:

        ```hcl title="provider.tf"
        provider "aws" {
          region = "us-west-2"
        }
        ```
      </Tab>

      <Tab title="GCP">
        ```bash
        # Configure credentials
        gcloud auth application-default login
        ```

        Set required variables:

        ```hcl title="terraform.tfvars"
        project_id = "my-gcp-project"
        region = "us-central1"
        ```
      </Tab>
    </Tabs>

    <Info>
      Files like `provider.tf` and `terraform.tfvars` are preserved across builds and won't be overwritten.
    </Info>
  </Step>

  <Step title="Initialize Terraform">
    Download providers and modules:

    ```bash
    terraform init -upgrade
    ```

    This downloads:
    - Cloud provider Terraform providers (AWS, GCP, etc.)
    - Plugin modules referenced by your platform
    - Backend configuration (if configured)
  </Step>

  <Step title="Preview Changes">
    Review what Terraform will create:

    ```bash
    terraform plan
    ```

    Output shows:
    - Resources to be created (`+`)
    - Resources to be modified (`~`)
    - Resources to be deleted (`-`)

    <Warning>
      Always review the plan carefully before applying, especially in production environments.
    </Warning>
  </Step>

  <Step title="Deploy">
    Apply the Terraform configuration:

    ```bash
    terraform apply
    ```

    Terraform will:
    1. Show the plan again
    2. Ask for confirmation
    3. Create resources in your cloud account
    4. Save state to track resources

    ```bash
    Apply complete! Resources: 15 added, 0 changed, 0 destroyed.

    Outputs:
    entrypoint_web_url = "https://d123abc.cloudfront.net"
    service_api_function_name = "my-app-api"
    ```
  </Step>

  <Step title="Verify Deployment">
    Test your deployed application:

    ```bash
    # Get the entrypoint URL from outputs
    terraform output entrypoint_web_url

    # Test the endpoint
    curl https://d123abc.cloudfront.net/api/health
    ```
  </Step>
</Steps>

## Managing Deployments

### Updating Your Application

When you make changes to your project:

1. **Rebuild Terraform:**
   ```bash
   suga build
   ```

2. **Preview changes:**
   ```bash
   cd terraform/stacks/my-app
   terraform plan
   ```

3. **Apply updates:**
   ```bash
   terraform apply
   ```

Terraform intelligently updates only what changed:
- Modified services are redeployed
- New resources are created
- Removed resources are deleted
- Unchanged resources remain untouched

### Deploying Code Updates

When you update service code without changing infrastructure:

```bash
# Simply re-run terraform apply
cd terraform/stacks/my-app
terraform apply
```

Terraform automatically:
1. Builds new container images from your updated code
2. Pushes images to the container registry (ECR, Artifact Registry, etc.)
3. Updates services to use the new images
4. Handles rolling deployments with zero downtime

No manual Docker commands needed - the generated Terraform includes container build and push logic.

<Info>
  CI/CD pipelines typically automate this by running `terraform apply` on every commit. See the [CI/CD Authentication Guide](/guides/cicd-authentication) for details.
</Info>

### Rolling Back

If a deployment causes issues, roll back:

```bash
# Revert code changes
git revert <commit-hash>

# Rebuild Terraform
suga build

# Apply previous configuration
cd terraform/stacks/my-app
terraform apply
```

Or roll back to a previous Terraform state:

```bash
# List state backups
terraform state list

# If using versioned state backend, restore previous version
# (AWS S3, GCS, Terraform Cloud all support versioning)
```

### Destroying Resources

When you're done with a deployment:

```bash
cd terraform/stacks/my-app
terraform destroy
```

<Warning>
  `terraform destroy` permanently deletes all cloud resources. Databases, buckets, and all data will be lost. Use with extreme caution, especially in production.
</Warning>

## Multi-Environment Deployments

Deploy the same application to multiple environments (dev, staging, production) using Terraform workspaces and environment-specific variable files. This allows you to maintain a single infrastructure definition while customizing configuration per environment.

<Card title="Environment Management Guide" icon="layers" href="/deploy/environment-management" horizontal>
  Learn detailed strategies for managing multiple environments with Terraform workspaces and promotion workflows
</Card>

## Cloud Provider Setup

Each cloud provider requires specific credentials and permissions. Detailed setup instructions including required permissions, authentication methods, and provider configuration are available in the provider-specific guides:

<CardGroup cols={2}>
  <Card title="AWS Deployment" icon="aws" href="/deploy/aws">
    AWS credentials, IAM permissions, and configuration
  </Card>

  <Card title="GCP Deployment" icon="google" href="/deploy/gcp">
    GCP service accounts, permissions, and configuration
  </Card>

  <Card title="Azure Deployment" icon="microsoft" href="/deploy/azure">
    Azure credentials, RBAC, and configuration
  </Card>
</CardGroup>

## Terraform State Management

Terraform state tracks deployed resources and must be managed carefully. By default, state is stored locally, which is suitable for personal projects but not recommended for teams. For production deployments, use a remote backend for state locking, versioning, and team collaboration.

<Card title="Terraform Backend Configuration" icon="database" href="/guides/terraform-backend-config" horizontal>
  Complete guide to configuring remote state backends (S3, GCS, Terraform Cloud)
</Card>

## CI/CD Integration

Automate deployments with CI/CD pipelines to build infrastructure and deploy on every commit. Common patterns include GitHub Actions, GitLab CI, CircleCI, and Jenkins.

<Card title="CI/CD Authentication Guide" icon="key" href="/guides/cicd-authentication" horizontal>
  Learn how to authenticate Suga in CI/CD pipelines with example workflows
</Card>

## Best Practices

### 1. Always Preview Before Applying

```bash
terraform plan  # Review changes
terraform apply  # Only after reviewing
```

### 2. Use Remote State for Teams

Configure a remote backend for team deployments. See the [Terraform Backend Configuration](/guides/terraform-backend-config) guide.

### 3. Separate Environments

Use Terraform workspaces or separate state files. See the [Environment Management](/deploy/environment-management) guide.

### 4. Version Control Everything

Commit generated Terraform to git:

```bash
git add terraform/
git commit -m "Update infrastructure"
```

### 5. Test in Non-Production First

Always deploy to dev/staging before production:

```bash
# Deploy to dev
terraform workspace select dev
terraform apply

# Test thoroughly
# Then deploy to prod
terraform workspace select prod
terraform apply
```

### 6. Use Terraform Variables for Configuration

Use variable files for environment-specific configuration. See the [Terraform Configuration](/deploy/terraform-configuration) guide.

### 7. Monitor Deployments

Set up monitoring for deployed resources:
- CloudWatch (AWS)
- Cloud Monitoring (GCP)
- Application Performance Monitoring (APM) tools

### 8. Document Your Deployments

Maintain deployment documentation:

```markdown title="DEPLOYMENT.md"
## Production Deployment

1. Ensure tests pass: `npm test`
2. Build infrastructure: `suga build`
3. Review changes: `terraform plan`
4. Deploy: `terraform apply`
5. Verify: `curl https://api.example.com/health`
6. Monitor: Check CloudWatch dashboard
```

## Troubleshooting

### Common Deployment Issues

**"No valid credential sources found"**

Solution: Configure cloud provider credentials properly.

**"Resource already exists"**

Solution: Import existing resource into Terraform state:
```bash
terraform import <resource_type>.<name> <resource_id>
```

**"State lock timeout"**

Solution: Another apply is running, or a previous one crashed. Release lock:
```bash
terraform force-unlock <lock-id>
```

**"Plan shows unwanted changes"**

Solution: Check for drift between state and actual resources:
```bash
terraform refresh
terraform plan
```

## Learn More

<CardGroup cols={2}>
  <Card title="Infrastructure Generation" icon="hammer" href="/foundations/infrastructure-generation">
    Understand how Terraform is generated
  </Card>

  <Card title="Environment Management" icon="layers" href="/deploy/environment-management">
    Manage multiple deployment environments
  </Card>

  <Card title="Terraform Configuration" icon="code" href="/deploy/terraform-configuration">
    Best practices for Terraform configuration
  </Card>

  <Card title="Local Development" icon="laptop" href="/foundations/local-development">
   How to develop applications locally with Suga
  </Card>
</CardGroup>
